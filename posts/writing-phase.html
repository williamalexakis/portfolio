<!DOCTYPE html>

<html lang="en">
    
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Writing My Own Programming Language • William Alexakis</title>
    <meta name="description" content="How I built Phase, my own interpreted programming language, from scratch to bridge the gap between high-level and low-level languages.">
    <meta name="keywords" content="Phase, programming language, interpreter, compiler, bytecode, virtual machine, lexer, parser, type checker, static typing, C programming">
    <meta name="author" content="William Alexakis">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://williamalexakis.com/posts/writing-phase.html">

    <meta name="title" content="Writing My Own Programming Language • William Alexakis">
    <meta property="og:title" content="Writing My Own Programming Language • William Alexakis">
    <meta property="og:description" content="How I built Phase, my own interpreted programming language, from scratch to bridge the gap between high-level and low-level languages.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://williamalexakis.com/posts/writing-phase.html">
    <meta property="og:image" content="https://williamalexakis.com/assets/icons/social-share.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="William Alexakis">
    <meta property="og:locale" content="en_US">
    <meta property="article:author" content="William Alexakis">
    <meta property="article:published_time" content="2025-12-04">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Writing My Own Programming Language • William Alexakis">
    <meta name="twitter:description" content="How I built Phase, my own interpreted programming language, from scratch to bridge the gap between high-level and low-level languages.">
    <meta property="twitter:image" content="https://williamalexakis.com/assets/icons/social-share.png">
    <meta name="twitter:image:alt" content="William Alexakis monogram logo">

    <meta name="theme-color" content="#020408">
    <meta name="color-scheme" content="dark">

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="../styles.css" />
    <link rel="stylesheet" href="../blog-styles.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />

    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@graph": [
            {
                "@type": "Person",
                "@id": "https://williamalexakis.com/#person",
                "name": "William Alexakis",
                "url": "https://williamalexakis.com/",
                "jobTitle": "Software Engineer",
                "description": "15-year-old student software engineer writing systems software from scratch.",
                "email": "mailto:w.alexakis@icloud.com",
                "image": "https://williamalexakis.com/assets/icons/social-share.png",
                "sameAs": [
                    "https://github.com/williamalexakis",
                    "https://williamalexakis.com"
                ]
            },
            {
                "@type": "BlogPosting",
                "@id": "https://williamalexakis.com/posts/writing-phase.html#post",
                "url": "https://williamalexakis.com/posts/writing-phase.html",
                "headline": "Writing My Own Programming Language",
                "description": "How I built Phase, my own interpreted programming language, from scratch to bridge the gap between high-level and low-level languages.",
                "author": {
                    "@id": "https://williamalexakis.com/#person"
                },
                "publisher": {
                    "@id": "https://williamalexakis.com/#person"
                },
                "datePublished": "2025-12-04",
                "mainEntityOfPage": {
                    "@type": "WebPage",
                    "@id": "https://williamalexakis.com/posts/writing-phase.html"
                },
                "image": "https://williamalexakis.com/assets/icons/social-share.png",
                "inLanguage": "en",
                "keywords": [
                    "Phase",
                    "programming language",
                    "interpreter",
                    "compiler",
                    "bytecode",
                    "virtual machine",
                    "lexer",
                    "parser",
                    "type checker",
                    "static typing",
                    "C programming"
                ]
            }
        ]
    }
    </script>
</head>

<body>
    <header class="site-header">
        <div class="wrapper header__top">
            <p class="logo">William Alexakis</p>
        </div>
    </header>

    <main class="wrapper sections">
        <article class="blog-post">
            <a href="/" class="back-link">← Back</a>

            <h1>Writing My Own Programming Language</h1>
            <div class="blog-meta">4 Dec 2025</div>
            
            <div class="blog-content">
                <h2>How Phase Started</h2>
                
                <p>
                    Last summer, I was learning C. I liked the control it provided but I kept being frustrated by its lack of clarity; I frequently found myself having to write many lines of code just to accomplish something that was much simpler in Python.
                </p>
                
                <p>
                    But then I'd switch back to Python for some experiments. The clarity of the syntax was refreshing, but I became frustrated with the lack of control; I missed the certainty of static typing and performance awareness in C.
                </p>
                
                <p>
                    I was essentially stuck between Python and C, which inspired me to imagine what I really wanted in a language, which led to me create Phase -- a statically-typed bytecode-interpreted programming language that combines the expressiveness of high-level languages (like Python) with the explicitness of lower-level languages (like C).
                </p>
                
                <p>
                    I chose the name 'Phase' because it represents the shift between language levels, and pretty much every other unique name was already taken.
                </p>
                
                <h2>Why Build From Scratch?</h2>
                
                <p>
                    Despite the existence and popularity of tools like LLVM that could've made this a lot easier, every single part of Phase -- from the lexer to the virtual machine -- is fully handwritten by me.
                </p>
                
                <p>
                    This is because I wanted to understand each and every part of the pipeline, which allowed me to to shape the language exactly how I envisioned it.
                </p>
                
                <h2>The Importance of Diagnostics</h2>
                
                <p>
                    Something I put much thought into during Phase's planning was error messages. Since this was, in some way, my ideal language, I realized that it had to solve the issue of vague errors that I experienced in other languages.
                </p>
                
                <p>
                    So I created a system that's both informative and visually appealing.
                </p>
                
                <p>
                    Here's an example:
                </p>
                
                <pre><code class="language-none">┏ Fatal Error [102]: Expected ')'.
┃ --&gt; ../tests/missing_paren.phase:2:19-19
┃
┃ 2 |     out("a, b, c:"
┃   |                   ^
┃
┣ Help: Add ')' here.
┃ Suggestion:
┃ -     out("a, b, c:"
┃ +     out("a, b, c:")</code></pre>
                
                <p>
                    This message tells us:
                </p>
                
                <ul>
                    <li>What went wrong, in just a few words.</li>
                    <li>Where the problem occurred, with visual markers too.</li>
                    <li>Why it's a problem, including context for what was expected.</li>
                    <li>How we could fix it, with a direct fix to our code suggested.</li>
                </ul>
                
                <p>
                    Which is everything we need to solve the issue.
                </p>
                
                <h2>The Interpreter Itself</h2>
                
                <p>
                    Phase's interpreter has several stages:
                </p>
                
                <svg viewBox="0 0 700 100" style="width: 100%; max-width: 700px; margin: 2rem auto; display: block;">

                    <rect x="10" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-hover)" stroke-width="2"/>
                    <rect x="155" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-hover)" stroke-width="2"/>
                    <rect x="300" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-hover)" stroke-width="2"/>
                    <rect x="445" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-hover)" stroke-width="2"/>
                    <rect x="590" y="20" width="100" height="60" rx="4" fill="none" stroke="var(--border-hover)" stroke-width="2"/>

                    <path d="M 130 50 L 155 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                    <path d="M 275 50 L 300 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                    <path d="M 420 50 L 445 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                    <path d="M 565 50 L 590 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>

                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <polygon points="0 0, 10 3, 0 6" fill="var(--fg)" />
                        </marker>
                    </defs>

                    <text x="70" y="55" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Lexer</text>
                    
                    <text x="215" y="55" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Parser</text>
                    
                    <text x="360" y="47" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Type</text>
                    <text x="360" y="63" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Checker</text>
                    
                    <text x="505" y="47" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Bytecode</text>
                    <text x="505" y="63" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Generator</text>
                    
                    <text x="640" y="55" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">VM</text>
                </svg>
                
                <p>
                    Let's go through each stage now, following this basic line of Phase code:
                </p>
                
                <pre><code class="language-c">out("Hello world!")</code></pre>
                
                <p>
                    From beginning to end.
                </p>
                
                <h3>1. Lexer</h3>
                
                <p>
                    The lexer (short for lexical analyzer) is the very first stage, taking in raw source code -- an arbitrary character string -- and breaking it down into tokens that represent keywords, operators, types, and literals.
                </p>
                
                <p>
                    Our previous line of code will get tokenized into this form:
                </p>
                
                <pre><code class="language-none">OUT
LPAREN
STRING_LIT 'Hello world!'
RPAREN
NEWLINE</code></pre>
                
                <p>
                    These tokens are now organised and separated -- much easier to process than the original line of code.
                </p>
                
                <p>
                    The lexer also handles details like skipping whitespace, distinguishing between keywords and identifiers, and handling string literals with escape sequences.
                </p>
                
                <p>
                    In concept, it's simple, which is what I thought until I realized it was actually one of the most tedious and boring aspects of the whole project to implement correctly.
                </p>
                
                <h3>2. Parser</h3>
                
                <p>
                    Next, the parser takes the stream of tokens the lexer produced and constructs an Abstract Syntax Tree (AST) -- a hierarchy of the structure of the program.
                </p>
                
                <p>
                    I specifically implemented a recursive-descent parser, wherein each grammar rule is designated to a specific function. The parser starts at the top (program) level, and goes through each sublevel until there's none left.
                </p>
                
                <p>
                    So parsing our tokens gives us these nodes:
                </p>
                   
                <pre><code class="language-none">STATEMENT (OUT)
        ╰ EXPRESSION (STRING) ["Hello world!"]</code></pre>
                
                <p>
                    Our list of tokens from before is now an organized linear structure that can be easily followed.
                </p>
                
                <p>
                    The parser is also where syntax errors are caught and raised. For example, if you forget a closing parenthesis in your code, the parser knows this based on the previous tokens it encounters.
                </p>
                
                <h3>3. Type Checker</h3>
                
                <p>
                    This is where Phase's static typing is enforced. The type checker walks along the AST and verifies that all operations are correct, so you can't mismatch variable types in assignment or arithmetic.
                </p>
                
                <p>
                    Semantics are different from syntax: think of it like arranging words in a sentence (syntax) versus what the sentence actually means (semantics).
                </p>
                
                <p>
                    To demonstrate, this line of code is syntactically correct:
                </p>
                
                <pre><code class="language-rust">let x: int = "Hi"</code></pre>
                
                <p>
                    But we still get an error:
                </p>
                
                <pre><code class="language-none">┏ Fatal Error [108]: Type mismatch.
┃ --&gt; ../tests/type_mismatch.phase:3:5-14
┃
┃ 3 |     let x: int = "Hi"
┃   |     ^^^^^^^^^^
┃
┣ Help: Variable 'x' expects int but got str.
┃ Suggestion:
┃ -     let x: int = "Hi"
┃ +     let x: int = 0</code></pre>
                
                <p>
                    Because the code is semantically wrong, due to a type mismatch. However, our 'hello world' code is a statement and accepts any expression as an argument, so the type checker emits it as is.
                </p>
                
                <h3>4. Bytecode Generator</h3>
                
                <p>
                    The type-checked AST is now taken by the bytecode generator and compiled into bytecode: a custom, Assembly-like instruction set that's much simpler to execute than the AST itself.
                </p>
                
                <p>
                    For Phase, I specifically implemented a stack-based architecture, meaning that operations push and pop values from a storage 'stack' -- in the order of Last-In, First-Out (LIFO).
                </p>
                
                <p>
                    Our code's AST now compiles into this hexadecimal bytecode:
                </p>
                
                <pre><code class="language-c">00 00 00
01
18</code></pre>
                <p>
                    Which represents these opcodes:
                </p>
                
                <pre><code class="language-nasm">OP_PUSH_CONST 0   ; Push 'Hello world!' onto the stack
OP_PRINT          ; Print it
OP_HALT           ; Stop the program</code></pre>
                
                <p>
                    I designed Phase's instruction set with about 25 opcodes currently implemented. Bytecode generation was surprisingly interesting, and, in fact, it was one of my favourite aspects of creating Phase due to the total design control it provided.
                </p>
                
                <h3>5. Virtual Machine</h3>
                
                <p>
                    The pipeline ends with the virtual machine, which directly executes the bytecode. It maintains:
                </p>
                
                <ul>
                    <li>An instruction pointer tracking which instruction to execute next.</li>
                    <li>A stack for temporary values and computations.</li>
                    <li>A global environment for holding variables.</li>
                </ul>
                
                <p>
                    The VM functions like a very simple CPU running a fetch-decode-execute cycle: it reads an instruction, decides what operation to perform, runs it, and moves onto the next instruction.
                </p>
                
                <p>
                    So, we finally produce an output from our code:
                </p>
                
                <pre><code class="language-none">Hello world!</code></pre>
                
                <p>
                    Creating the VM was a great learning experience for interpreter design, and it was also quite satisfying to program the actual outputs for my source code after getting only debug info so far.
                </p>
                
                <h2>Design Decisions</h2>
                
                <p>
                    I had to make a lot of tradeoffs when planning and creating Phase. Let's go through the most important ones I made:
                </p>
                
                <h3>Interpreter vs Transpiler</h3>
                
                <p>
                    Originally, Phase was meant to be a transpiler that converted source code to C code, which would then be built and executed. That was actually the first functioning implementation of Phase that I wrote.
                </p>
                
                <p>
                    However, as I tested my first Phase programs, I realised that the build-run pipeline was very tedious, as I had to compile code twice in a row and then execute it. Even though I felt that a transpiler would demonstrate more low-level knowledge, I decided to convert Phase to an interpreter by switching out the backend for a bytecode generator and a VM, while keeping the same lexer and parser.
                </p>
                
                <h3>Static Typing vs Dynamic Typing</h3>
                
                <p>
                    Static typing adds complexity with type checking and more sophisticated error handling, but I felt that the benefits outweighed dynamic typing, especially with bug catching.
                </p>
                
                <p>
                    I originally implemented C-style variable type declarations because they were simple and explicit. However, after some feedback from a person online, I replaced this with Rust-style declarations to better support the updates that came soon after.
                </p>
                
                <h3>Stack-Based VM vs Register-Based VM</h3>
                
                <p>
                    I chose a stack-based architecture over register-based because it's much simpler to implement, but it's also slower because of more stack operations.
                </p>
                
                <p>
                    For Phase, I prioritized modularity over performance, and besides, there wouldn't be any noticeable difference between the two architectures for a language this small.
                </p>
                
                <h3>Python vs C</h3>
                
                <p>
                    I created the first prototype of Phase (called Luma at the time) in Python since I knew it much better than C, and got it working in a few days with extremely basic features.
                </p>
                
                <p>
                    However, writing it in Python made me feel as if I were cheating myself in a way, so I decided to challenge myself by writing it fully in C, which greatly accelerated my learning by forcing me to confront concepts I was unfamiliar with at the time.
                </p>
                
                <h2>What's Next</h2>
                
                <p>
                    I consider Phase to be finished, with enough features to write a variety of small practical programs. For example, here is a fibonacci sequence program:
                </p>
                
                <pre><code class="language-rust">func fibonacci(n: int): void {
    let (a, b): int = (0, 1)
    let (next, count): int = (b, 1)
    
    while count <= n {
        out(next)
        count += 1
        a = b
        b = next
        next = a + b
    }
}

entry {
    fibonacci(10)
}</code></pre>
                
                <p>
                    But if I were to revisit it in the future, these would be the next things I would work on:
                </p>
                
                <ul>
                    <li>An arena memory allocator</li>
                    <li>JIT bytecode compilation</li>
                    <li>Standard input</li>
                </ul>
                
                <h2>What I Learned</h2>
                
                <p>
                    Creating Phase taught me many things like how source code is converted to executable instructions in interpreters, how to plan and write a large project in a low-level language like C, and how to think in a systems-oriented way so you're conscious of things like design decisions and your program's architecture.
                </p>
                
                <p>
                    It also demonstrated the effectiveness of project-based learning, which is something I really value; I couldn't have learned all these skills if I didn't actually create a programming language.
                </p>
                
                <p>
                    You can check out Phase on <a href="https://github.com/williamalexakis/phase" target="_blank" rel="noreferrer">GitHub</a>.
                </p>
            </div>
        </article>
    </main>
    
    <footer class="site-footer">
        <div class="wrapper footer__inner">
            <p class="footer-copy">© William Alexakis 2026</p>
            <span class="footer-sep">•</span>
            <a href="/assets/docs/William_Alexakis_CV.pdf" download target="_blank" rel="noreferrer">CV</a>
            <span class="footer-sep">•</span>
            <a href="mailto:w.alexakis@icloud.com">Email</a>
            <span class="footer-sep">•</span>
            <a href="https://github.com/williamalexakis" target="_blank" rel="noreferrer">GitHub</a>
            <span class="footer-sep">•</span>
            <a href="https://www.linkedin.com/in/williamalexakis" target="_blank" rel="noreferrer">LinkedIn</a>
        </div>
    </footer>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-nasm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
</body>

</html>
