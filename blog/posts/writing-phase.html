<!DOCTYPE html>

<html lang="en">
    
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Writing My Own Programming Language • William Alexakis</title>
    <meta name="description" content="How I built Phase, my own interpreted programming language, from scratch to bridge the gap between high-level and low-level languages.">
    <meta name="keywords" content="Phase, programming language, interpreter, compiler, bytecode, virtual machine, lexer, parser, type checker, static typing, C programming">
    <meta name="author" content="William Alexakis">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://williamalexakis.com/blog/posts/writing-phase.html">

    <meta name="title" content="Writing My Own Programming Language • William Alexakis">
    <meta property="og:title" content="Writing My Own Programming Language • William Alexakis">
    <meta property="og:description" content="How I built Phase, my own interpreted programming language, from scratch to bridge the gap between high-level and low-level languages.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://williamalexakis.com/blog/posts/writing-phase.html">
    <meta property="og:image" content="https://williamalexakis.com/assets/icons/social-share.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="William Alexakis">
    <meta property="og:locale" content="en_US">
    <meta property="article:author" content="William Alexakis">
    <meta property="article:published_time" content="2025-04-12">
    <meta property="article:modified_time" content="2025-12-07">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Writing My Own Programming Language • William Alexakis">
    <meta name="twitter:description" content="How I built Phase, my own interpreted programming language, from scratch to bridge the gap between high-level and low-level languages.">
    <meta property="twitter:image" content="https://williamalexakis.com/assets/icons/social-share.png">
    <meta name="twitter:image:alt" content="William Alexakis monogram logo">

    <meta name="theme-color" content="#020408">
    <meta name="color-scheme" content="dark">

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="../../styles.css" />
    <link rel="stylesheet" href="../blog-styles.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />

    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@graph": [
            {
                "@type": "Person",
                "@id": "https://williamalexakis.com/#person",
                "name": "William Alexakis",
                "url": "https://williamalexakis.com/",
                "jobTitle": "Software Engineer",
                "description": "15-year-old software engineer building low-level tools and real-world software systems.",
                "email": "mailto:w.alexakis@icloud.com",
                "image": "https://williamalexakis.com/assets/icons/social-share.png",
                "sameAs": [
                    "https://github.com/williamalexakis",
                    "https://williamalexakis.com/blog"
                ]
            },
            {
                "@type": "BlogPosting",
                "@id": "https://williamalexakis.com/blog/posts/writing-phase.html#post",
                "url": "https://williamalexakis.com/blog/posts/writing-phase.html",
                "headline": "Writing My Own Programming Language",
                "description": "How I built Phase, my own interpreted programming language, from scratch to bridge the gap between high-level and low-level languages.",
                "author": {
                    "@id": "https://williamalexakis.com/#person"
                },
                "publisher": {
                    "@id": "https://williamalexakis.com/#person"
                },
                "datePublished": "2025-04-12",
                "dateModified": "2025-12-07",
                "mainEntityOfPage": {
                    "@type": "WebPage",
                    "@id": "https://williamalexakis.com/blog/posts/writing-phase.html"
                },
                "image": "https://williamalexakis.com/assets/icons/social-share.png",
                "inLanguage": "en",
                "keywords": [
                    "Phase",
                    "programming language",
                    "interpreter",
                    "compiler",
                    "bytecode",
                    "virtual machine",
                    "lexer",
                    "parser",
                    "type checker",
                    "static typing",
                    "C programming"
                ]
            }
        ]
    }
    </script>
</head>

<body>
    <header class="site-header">
        <div class="wrapper header__inner">
            <p class="logo">William Alexakis • Blog</p>
        </div>
    </header>
    
    <div class="wrapper">
        <div class="subheader-nav">
            <a href="/">→ Portfolio</a>
        </div>
    </div>

    <main class="wrapper sections">
        <article class="blog-post">
            <a href="/blog" class="back-link">← Back to Blog</a>
            
            <h1>Writing My Own Programming Language</h1>
            <div class="blog-meta"><time datetime="2025-04-12">Created 4/12/2025 • Last edit 22/1/2026</time></div>
            
            <div class="blog-content">
                <h2>How Phase Started</h2>
                
                <p>
                    Last summer, I was deep into learning C. I loved the control it provided but I kept being frustrated by its lack of clarity; I frequently found myself having to write many lines of code just to accomplish something that was much simpler in Python.
                </p>
                
                <p>
                    But then I'd switch back to Python for some experiments. The clarity of the syntax was refreshing, but I became frustrated again — this time because of the lack of control; I missed the certainty of static typing and performance awareness in C.
                </p>
                
                <p>
                    I was stuck between Python's clarity and C's control.
                </p>
                
                <p>
                    So I decided to build my own middleground: Phase — a statically-typed bytecode-interpreted programming language that combines the expressiveness of high-level languages (like Python) with the explicitness of lower-level languages (like C).
                </p>
                
                <p>
                    I chose the name 'Phase' because it represents the shift between language levels, and pretty much every other distinct name was already taken.
                </p>
                
                <h2>Why Build From Scratch?</h2>
                
                <p>
                    Despite the existence and popularity of tools like LLVM that could've made this a lot easier, every single part of Phase — from lexer to virtual machine — is fully handwritten.
                </p>
                
                <p>
                    This is because I wanted to understand each and every part of the pipeline; I wanted to control exactly how a line of source code gets converted into tokens, into AST nodes, into bytecode, and then executed by the VM. This allowed me to to shape the language exactly how I envisioned it.
                </p>
                
                <h2>The Importance of Diagnostics</h2>
                
                <p>
                    Something I put much thought into during Phase's planning was error messages. Since this was, in some way, my ideal language, I realized that it had to solve the issue of vague or antagonistic errors that I experienced in other languages.
                </p>
                
                <p>
                    I believe that errors must work alongside you, not against you. So I created a system that's both informative and visually appealing.
                </p>
                
                <p>
                    Here's an example:
                </p>
                
                <pre><code class="language-none">┏ Fatal Error [102]: Expected ')'.
┃ --&gt; ../tests/missing_paren.phase:2:19-19
┃
┃ 2 |     out("a, b, c:"
┃   |                   ^
┃
┣ Help: Add ')' here.
┃ Suggestion:
┃ -     out("a, b, c:"
┃ +     out("a, b, c:")</code></pre>
                
                <p>
                    This message tells us:
                </p>
                
                <ul>
                    <li>What went wrong, in just a few words.</li>
                    <li>Where the problem occurred, with visual markers too.</li>
                    <li>Why it's a problem, including context for what was expected.</li>
                    <li>How we could fix it, with a direct fix suggested.</li>
                </ul>
                
                <p>
                    That's everything we need to solve the issue.
                </p>
                
                <h2>The Interpreter Itself</h2>
                
                <p>
                    Phase's interpreter possesses a multistage pipeline:
                </p>
                
                <svg viewBox="0 0 700 100" style="width: 100%; max-width: 700px; margin: 2rem auto; display: block;">

                    <rect x="10" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-strong)" stroke-width="2"/>
                    <rect x="155" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-strong)" stroke-width="2"/>
                    <rect x="300" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-strong)" stroke-width="2"/>
                    <rect x="445" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-strong)" stroke-width="2"/>
                    <rect x="590" y="20" width="100" height="60" rx="4" fill="none" stroke="var(--border-strong)" stroke-width="2"/>

                    <path d="M 130 50 L 155 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                    <path d="M 275 50 L 300 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                    <path d="M 420 50 L 445 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                    <path d="M 565 50 L 590 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>

                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <polygon points="0 0, 10 3, 0 6" fill="var(--fg)" />
                        </marker>
                    </defs>

                    <text x="70" y="55" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Lexer</text>
                    
                    <text x="215" y="55" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Parser</text>
                    
                    <text x="360" y="47" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Type</text>
                    <text x="360" y="63" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Checker</text>
                    
                    <text x="505" y="47" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Bytecode</text>
                    <text x="505" y="63" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Generator</text>
                    
                    <text x="640" y="55" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">VM</text>
                </svg>
                
                <p>
                    Let's go through each section now, following this basic line of Phase code:
                </p>
                
                <pre><code class="language-c">out("Hello world!")</code></pre>
                
                <p>
                    From beginning to end.
                </p>
                
                <h3>1. Lexer (Tokenization)</h3>
                
                <p>
                    The lexer (short for lexical analyzer) is the very first stage, taking in raw source code — an arbitrary character string — and breaking it down into tokens that represent keywords, operators, types, and literals.
                </p>
                
                <p>
                    Our previous line of code will get tokenized into this form:
                </p>
                
                <pre><code class="language-none">OUT
LPAREN
STRING_LIT 'Hello world!'
RPAREN
NEWLINE</code></pre>
                
                <p>
                    These tokens are now organised and therefore much easier to process than the original line of code.
                </p>
                
                <p>
                    The lexer also handles details like skipping whitespace, distinguishing between keywords and identifiers, and handling string literals with escape sequences.
                </p>
                
                <p>
                    Conceptually, it's simple, which is what I thought until I realized it was actually one of the most tedious and boring aspects of the whole project to implement correctly.
                </p>
                
                <h3>2. Parser (Syntax Analysis)</h3>
                
                <p>
                    Next, the parser takes the stream of tokens the lexer produced and constructs an Abstract Syntax Tree (AST) — a hierarchy of the grammatical structure of the program.
                </p>
                
                <p>
                    I specifically implemented a recursive-descent parser, wherein each grammar rule is designated to a specific function. The parser starts at the top (program) level, and goes through each sublevel until there's none left.
                </p>
                
                <p>
                    So parsing our tokens gives us these nodes:
                </p>
                   
                <pre><code class="language-none">STATEMENT (OUT)
        ╰ EXPRESSION (STRING) ["Hello world!"]</code></pre>
                
                <p>
                    Our list of tokens from before is now a rigid linear structure that can be easily followed.
                </p>
                
                <p>
                    The parser is also where syntax errors are caught. If you, for instance, reference an undeclared variable or forget a parentheses, the parser knows because the current token doesn't match the expected grammar based on previous tokens.
                </p>
                
                <h3>3. Type Checker (Semantic Analysis)</h3>
                
                <p>
                    This is where Phase's static typing is enforced. The type checker walks along the AST and verifies that all operations are correct, so you can't mismatch variable types in assignment or arithmetic.
                </p>
                
                <p>
                    Semantics are different from syntax: think of it like arranging words in a sentence (syntax) versus what the sentence actually means (semantics).
                </p>
                
                <p>
                    To demonstrate, this line of code is syntactically correct:
                </p>
                
                <pre><code class="language-rust">let x: int = "Hi"</code></pre>
                
                <p>
                    But we still get an error:
                </p>
                
                <pre><code class="language-none">┏ Fatal Error [108]: Type mismatch.
┃ --&gt; ../tests/type_mismatch.phase:3:5-14
┃
┃ 3 |     let x: int = "Hi"
┃   |     ^^^^^^^^^^
┃
┣ Help: Variable 'x' expects int but got str.
┃ Suggestion:
┃ -     let x: int = "Hi"
┃ +     let x: int = 0</code></pre>
                
                <p>
                    Because the code is semantically wrong, due to a type mismatch. However, our 'hello world' code is a statement and accepts any expression as an argument, so the type checker emits it as is.
                </p>
                
                <h3>4. Bytecode Generator (Compilation)</h3>
                
                <p>
                    The type-checked AST is now taken by the bytecode generator and compiled into bytecode: a custom, Assembly-like instruction set that's much simpler to execute than the AST itself.
                </p>
                
                <p>
                    For Phase, I specifically implemented a stack-based architecture, meaning that operations push and pop values from a storage 'stack' — in the order of Last-In, First-Out (LIFO).
                </p>
                
                <p>
                    Our code's AST now compiles into this hexadecimal bytecode:
                </p>
                
                <pre><code class="language-c">00 00 00
01
18</code></pre>
                <p>
                    Which represents these opcodes:
                </p>
                
                <pre><code class="language-nasm">OP_PUSH_CONST 0   ; Push 'Hello world!' onto the stack
OP_PRINT          ; Print 'Hello world!'
OP_HALT           ; Stop the program</code></pre>
                
                <p>
                    I designed Phase's instruction set to be minimal rather than superfluous, with about 25 opcodes currently implemented. Bytecode generation was surprisingly interesting, and, in fact, one of my favourite aspects of creating Phase due to the total design control it provided.
                </p>
                
                <h3>5. Virtual Machine (Execution)</h3>
                
                <p>
                    The pipeline ends with the virtual machine, which directly executes the bytecode. It maintains:
                </p>
                
                <ul>
                    <li>An instruction pointer tracking which instruction to execute next.</li>
                    <li>A stack for temporary values and computations.</li>
                    <li>A global environment for holding variables.</li>
                </ul>
                
                <p>
                    The VM functions like a very simple CPU running a fetch-decode-execute cycle: it reads an instruction, decides what operation to perform, runs it, and moves onto the next instruction.
                </p>
                
                <p>
                    So, we finally produce an output from our code:
                </p>
                
                <pre><code class="language-none">Hello world!</code></pre>
                
                <p>
                    Creating the VM was a great learning experience for interpreter design, and I don't regret writing it myself instead of using a ready-made tool. It was also quite satisfying to program tangible outputs for my source code after getting only debug info so far.
                </p>
                
                <h2>Design Decisions and Tradeoffs</h2>
                
                <p>
                    Every programming language has design tradeoffs. Here are some of my key decisions I made and why:
                </p>
                
                <h3>Interpreter vs Transpiler</h3>
                
                <p>
                    Originally, Phase was meant to be a transpiler that converted source code to C code, which would then be built and executed. That was actually the first functioning implementation of Phase that I wrote.
                </p>
                
                <p>
                    However, as I tested my first Phase programs, I realised that the build-run pipeline was very tedious; I had to compile code twice in a row and then execute. Even though I felt that a transpiler would demonstrate more low-level knowledge, I decided to convert Phase to an interpreter by switching out the backend for a bytecode generator and a VM, while keeping the same lexer and parser.
                </p>
                
                <h3>Static Typing vs Dynamic Typing</h3>
                
                <p>
                    Static typing adds complexity with type checking and more sophisticated error handling, but I felt that the benefits outweighed dynamic typing witb comprehensive bug catching and clear intent in code.
                </p>
                
                <p>
                    I originally settled on simple C-style variable type declarations because I wanted the confidence of knowing exactly what the compiler knows, while retaining simplicity. However, after some feedback from a person online, I replaced this with Rust-style declarations to better support the updates that came soon after.
                </p>
                
                <h3>Stack-Based VM vs Register-Based VM</h3>
                
                <p>
                    I chose a stack-based architecture over register-based because it's much simpler to implement, but it's also slower because of more stack operations.
                </p>
                
                <p>
                    For Phase, I prioritized modularity and extensibility over raw performance. Besides, Phase's small scope means there wouldn't be any noticeable different between the two architectures.
                </p>
                
                <h3>Python vs C</h3>
                
                <p>
                    I created the first prototype of Phase (called Luma at the time) in Python since I knew it much better than C, and got it working in a few days with extremely basic features.
                </p>
                
                <p>
                    However, I realized it felt almost too easy to implement it in Python, so I decided to challenge myself by writing it fully in C, which greatly accelerated my learning by forcing me to confront concepts I was unfamiliar with at the time.
                </p>
                
                <h2>What's Next</h2>
                
                <p>
                    Phase is finished for now, with enough features to write a variety of small, useful programs. For example, here is a fibonacci sequence program:
                </p>
                
                <pre><code class="language-rust">func fibonacci(n: int): void {
    let (a, b): int = (0, 1)
    let (next, count): int = (b, 1)
    
    while count <= n {
        out(next)
        count += 1
        a = b
        b = next
        next = a + b
    }
}

entry {
    fibonacci(10)
}</code></pre>
                
                <p>
                    But if I were to revisit it in the future, these would be the next features on my roadmap:
                </p>
                
                <ul>
                    <li>An arena memory allocator</li>
                    <li>JIT bytecode compilation</li>
                    <li>Standard input</li>
                    <li>Aggregate data types</li>
                </ul>
                
                <h2>What I Learned</h2>
                
                <p>Building Phase taught me more about programming languages than any course or book could. I now understand:</p>
                
                <ul>
                    <li>How compilers translate high-level code into executable instructions.</li>
                    <li>Why certain language features exist and what tradeoffs they involve.</li>
                    <li>The complexity of seemingly simple things like lexing or error messages.</li>
                    <li>How to design systems that are both functional and easily extendable.</li>
                </ul>
                
                <p>
                    More importantly, it demonstrated the power of project-based learning; I couldn't have learned all these skills if I didn't actually create my language.
                </p>
                
                <p>
                    You can check out Phase on <a href="https://github.com/williamalexakis/phase" target="_blank" rel="noreferrer">GitHub</a>.
                </p>
            </div>
        </article>
    </main>
    
    <footer class="site-footer">
        <div class="wrapper footer__inner">
            © William Alexakis 2026
        </div>
    </footer>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-nasm.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>
</body>

</html>
