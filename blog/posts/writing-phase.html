<!DOCTYPE html>

<html lang="en">
    
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Writing My Own Programming Language • William Alexakis</title>
    <meta name="description" content="How I built Phase, a statically-typed bytecode-interpreted language, from scratch to bridge the gap between high-level and low-level languages.">
    <meta name="keywords" content="Phase, programming language, interpreter, compiler, bytecode, virtual machine, lexer, parser, type checker, static typing, C programming">
    <meta name="author" content="William Alexakis">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://williamalexakis.com/blog/posts/writing-phase.html">

    <meta name="title" content="Writing My Own Programming Language • William Alexakis">
    <meta property="og:title" content="Writing My Own Programming Language • William Alexakis">
    <meta property="og:description" content="How I built Phase, a statically-typed bytecode-interpreted language, from scratch to bridge the gap between high-level and low-level languages.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://williamalexakis.com/blog/posts/writing-phase.html">
    <meta property="og:image" content="https://williamalexakis.com/assets/icons/social-share.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="William Alexakis">
    <meta property="og:locale" content="en_US">
    <meta property="article:author" content="William Alexakis">
    <meta property="article:published_time" content="2025-04-12">
    <meta property="article:modified_time" content="2025-12-07">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Writing My Own Programming Language • William Alexakis">
    <meta name="twitter:description" content="How I built Phase, a statically-typed bytecode-interpreted language, from scratch to bridge the gap between high-level and low-level languages.">
    <meta property="twitter:image" content="https://williamalexakis.com/assets/icons/social-share.png">
    <meta name="twitter:image:alt" content="William Alexakis monogram logo">

    <meta name="theme-color" content="#020408">
    <meta name="color-scheme" content="dark">

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600&display=swap" rel="stylesheet"/>
    <link rel="stylesheet" href="../../styles.css" />
    <link rel="stylesheet" href="../blog-styles.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />

    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@graph": [
            {
                "@type": "Person",
                "@id": "https://williamalexakis.com/#person",
                "name": "William Alexakis",
                "url": "https://williamalexakis.com/",
                "jobTitle": "Software Engineer",
                "description": "15-year-old software engineer building low-level tools and real-world software systems.",
                "email": "mailto:w.alexakis@icloud.com",
                "image": "https://williamalexakis.com/assets/icons/social-share.png",
                "sameAs": [
                    "https://github.com/williamalexakis",
                    "https://williamalexakis.com/blog"
                ]
            },
            {
                "@type": "BlogPosting",
                "@id": "https://williamalexakis.com/blog/posts/writing-phase.html#post",
                "url": "https://williamalexakis.com/blog/posts/writing-phase.html",
                "headline": "Writing My Own Programming Language",
                "description": "How I built Phase, a statically-typed bytecode-interpreted language, from scratch to bridge the gap between high-level and low-level languages.",
                "author": {
                    "@id": "https://williamalexakis.com/#person"
                },
                "publisher": {
                    "@id": "https://williamalexakis.com/#person"
                },
                "datePublished": "2025-04-12",
                "dateModified": "2025-12-07",
                "mainEntityOfPage": {
                    "@type": "WebPage",
                    "@id": "https://williamalexakis.com/blog/posts/writing-phase.html"
                },
                "image": "https://williamalexakis.com/assets/icons/social-share.png",
                "inLanguage": "en",
                "keywords": [
                    "Phase",
                    "programming language",
                    "interpreter",
                    "compiler",
                    "bytecode",
                    "virtual machine",
                    "lexer",
                    "parser",
                    "type checker",
                    "static typing",
                    "C programming"
                ]
            }
        ]
    }
    </script>
</head>

<body>
    <header class="site-header">
        <div class="wrapper header__inner">
            <p class="logo">William Alexakis • Blog</p>
        </div>
    </header>
    
    <div class="wrapper">
        <div class="subheader-nav">
            <a href="/">→ Portfolio</a>
        </div>
    </div>

    <main class="wrapper sections">
        <article class="blog-post">
            <a href="/blog" class="back-link">← Back to Blog</a>
            
            <h1>Writing My Own Programming Language</h1>
            <div class="blog-meta"><time datetime="2025-04-12">4/12/2025</time></div>
            
            <div class="blog-content">
                <h2>The Origin Story</h2>
                
                <p>
                    Last summer, I was deep into learning C. I loved the control it provided — pointers, memory management, hardware access — but I kept being frustrated by one thing: <em>the boilerplate</em>. Every time I wanted to do something that seemed simple, I actually had to write dozens of lines of code.
                </p>
                
                <p>
                    Then I'd switch back to Python for some prototyping, and while the clarity of the syntax was refreshing, I immediately missed the control of C. There was no static typing, no pass-by-reference, no way of knowing if my code would work until I ran it. I felt stuck between Python's clarity and C's control.
                </p>
                
                <p>
                    So I decided to build <em>my own</em> middleground: <strong>Phase</strong> — a statically-typed, bytecode-interpreted language that combines the expressiveness of high-level languages (like Python) with the explicitness of lower-level languages (like C).
                </p>
                
                <h2>Why Build From Scratch?</h2>
                
                <p>
                    Despite the existence of many tools like ANTLR or LLVM that could've made this a lot easier, every part of Phase — from lexer to VM — is fully handwritten.
                </p>
                
                <p>
                    <em>Why?</em> Because I wanted to understand each and every part of the pipeline; I didn't want to treat any section like a black box. I wanted to control <em>exactly</em> how a line of source code gets converted into tokens, into AST nodes, into bytecode, and then executed by the VM. And the only way to truly understand and control something is by building it yourself.
                </p>
                
                <h2>The Importance of Diagnostics</h2>
                
                <p>
                    Another thing I thought of during Phase's planning was error messages — specifically, informative, helpful, and visually appealing ones. Too many languages treat errors as afterthoughts, providing you with vague messages that don't actually give you what you <em>want</em>.
                </p>
                
                <p>
                    I believe that good diagnostics are just as important as good semantics. Phase's error system reflects that.
                </p>
                
                <p>
                    Take a look at this example error message:
                </p>
                
                <pre><code class="language-none">┏ Fatal Error [102]: Expected ')'.
┃ --&gt; ../tests/missing_paren.phase:2:19-19
┃
┃ 2 |     out("a, b, c:"
┃   |                   ^
┃
┣ Help: Add ')' here.
┃ Suggestion:
┃ -     out("a, b, c:"
┃ +     out("a, b, c:")</code></pre>
                
                <p>
                    This tells us:
                </p>
                
                <ul>
                    <li><strong>What</strong> went wrong, in just a few words.</li>
                    <li><strong>Where</strong> the error occurred, with visual markers too.</li>
                    <li><strong>Why</strong> it's a problem, including context for what was expected.</li>
                    <li><strong>How</strong> we could fix it, with a direct code suggestion.</li>
                </ul>
                
                <p>
                    That's everything we need to solve the issue.
                </p>
                
                <h2>The Interpreter Pipeline</h2>
                
                <p>
                    Phase's interpreter follows a classic multistage pipeline:
                </p>
                
                <svg viewBox="0 0 700 100" style="width: 100%; max-width: 700px; margin: 2rem auto; display: block;">

                    <rect x="10" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-strong)" stroke-width="2"/>
                    <rect x="155" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-strong)" stroke-width="2"/>
                    <rect x="300" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-strong)" stroke-width="2"/>
                    <rect x="445" y="20" width="120" height="60" rx="4" fill="none" stroke="var(--border-strong)" stroke-width="2"/>
                    <rect x="590" y="20" width="100" height="60" rx="4" fill="none" stroke="var(--border-strong)" stroke-width="2"/>

                    <path d="M 130 50 L 155 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                    <path d="M 275 50 L 300 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                    <path d="M 420 50 L 445 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                    <path d="M 565 50 L 590 50" stroke="var(--fg)" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>

                    <defs>
                        <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                            <polygon points="0 0, 10 3, 0 6" fill="var(--fg)" />
                        </marker>
                    </defs>

                    <text x="70" y="55" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Lexer</text>
                    
                    <text x="215" y="55" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Parser</text>
                    
                    <text x="360" y="47" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Type</text>
                    <text x="360" y="63" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Checker</text>
                    
                    <text x="505" y="47" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Bytecode</text>
                    <text x="505" y="63" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">Generator</text>
                    
                    <text x="640" y="55" fill="var(--fg)" font-size="16" font-weight="500" text-anchor="middle" font-family="Space Grotesk, sans-serif">VM</text>
                </svg>
                
                <p>
                    Let's go through each component.
                </p>
                
                <h3>1. Lexer (Tokenization)</h3>
                
                <p>
                    The lexer is the very first stage, taking in raw source code — an arbitrary string of characters — and break it down into <em>tokens</em>: meaningful units of the language, such as keywords, operators, and literals.
                </p>
                
                <p>
                    For example, this code:
                </p>
                
                <pre><code class="language-c">out("Hello world")</code></pre>
                
                <p>
                    Gets tokenized into:
                </p>
                
                <pre><code class="language-none">OUT
LPAREN
STRING_LIT 'Hello world'!
RPAREN
NEWLINE</code></pre>
                
                <p>
                    The lexer also handles details like skipping whitespace, recognizing keywords and identifiers, and handling string literals with escape sequences. Conceptually, it's simple, which is what I thought until I realized it was one of the most tedious aspects of the whole interpreter to get <em>right</em>.
                </p>
                
                <h3>2. Parser (Syntax Analysis)</h3>
                
                <p>
                    The parser takes the stream of tokens the lexer produced and constructs a hierarchical <em>Abstract Syntax Tree</em> (AST), which represents the grammatical structure of the program.
                </p>
                
                <p>
                    I implemented a recursive-descent parser — meaning that each grammar rule maps to a specific function.
                </p>
                
                <p>
                    For example, parsing the tokens we created earlier gives us this tree:
                </p>
                   
                <pre><code class="language-none">STATEMENT (OUT)
        ╰ EXPRESSION (STRING) ["Hello world!"]</code></pre>
                
                <p>
                    The parser is where syntax errors are caught. If you reference an undeclared variable or forget a parentheses, the parser knows because the token stream doesn't match the expected grammar.
                </p>
                
                <h3>3. Type Checker (Semantic Analysis)</h3>
                
                <p>
                    This is where Phase's static typing is enforced. The type checker walks the AST and verifies that operations are correct: you can't assign a string to an integer variable, you can't use a variable before you declare it, etc.
                </p>
                
                <p>
                    So while this is syntactically correct:
                </p>
                
                <pre><code class="language-c">int x = "hi"</code></pre>
                
                <p>
                    It's semantically wrong.
                </p>
                
                <h3>4. Bytecode Generator (Compilation)</h3>
                
                <p>
                    The bytecode generator takes the AST (after it passes type checking) and compiles it into <em>bytecode</em>: a custom, Assembly-like instruction set that's much simpler to execute than the AST itself.
                </p>
                
                <p>
                    Phase uses a stack-based architecture, meaning operations push and pop values from a storage stack — in the order of Last-In, First-Out (LIFO).
                </p>
                
                <p>
                    For example, our previous AST will compile into this hexadecimal bytecode:
                </p>
                
                <pre><code class="language-c">00 00 00
01
18</code></pre>
                <p>
                    Which represents these opcodes:
                </p>
                
                <pre><code class="language-nasm">OP_PUSH_CONST 0   ; Push 'Hello world!' onto the stack
OP_PRINT          ; Print 'Hello world!'
OP_HALT           ; Stop the program</code></pre>
                
                <p>
                    I designed Phase's instruction set to be intentionally minimal, with about 25 opcodes currently implemented. Bytecode generation was surprisingly interesting, and was one of my favourite aspects of creating Phase due to the total design control it provided.
                </p>
                
                <h3>5. Virtual Machine (Execution)</h3>
                
                <p>
                    The final component of the pipeline is the <em>VM</em>, which directly executes the bytecode. It maintains:
                </p>
                
                <ul>
                    <li>An <strong>instruction pointer</strong> tracking which instruction to execute next.</li>
                    <li>A <strong>stack</strong> for temporary values and computations.</li>
                    <li>A <strong>global environment</strong> for holding variables.</li>
                </ul>
                
                <p>
                    The VM functions like a very simple CPU, running a fetch-decode-execute loop: it reads an instruction, decides what operation to perform, runs it, and moves onto the next instruction.
                </p>
                
                <p>
                    So, for example, our bytecode is executed and this output is produced:
                </p>
                
                <pre><code class="language-none">Hello world!</code></pre>
                
                <p>
                    Creating the VM was a <em>great</em> learning experience for interpreter design, and I'm happy that I chose to write it myself instead of using a ready-made tool.
                </p>
                
                <h2>Design Decisions and Tradeoffs</h2>
                
                <p>
                    Every language design involves tradeoffs. Here are some of my key decisions I made and why:
                </p>
                
                <h3>Interpreter vs Transpiler</h3>
                
                <p>
                    Originally, Phase was meant to be a transpiler that converted source code to C code, which would then be built and executed. In fact, that was the first functioning implementation of Phase.
                </p>
                
                <p>
                    However, as I tested my first Phase programs, I realised that the build-run pipeline was <em>very</em> tedious. Even though I felt that a transpiler would demonstrate more low-level knowledge, I decided to convert Phase to an interpreter by switching out the backend for a bytecode generator and a VM, while keeping the same lexer and parser.
                </p>
                
                <h3>Static Typing vs Dynamic Typing</h3>
                
                <p>
                    Static typing adds complexity — you need type checker, explicit declarations, and more sophisticated error handling. But I felt that the benefits outweight dynamic typing: comprehensive bug catching, better tooling, and clear intent in code.
                </p>
                
                <p>
                    I settled on simple, C-style type declarations because I wanted the confidence of knowing exactly what the compiler knows, while keeping simplicity.
                </p>
                
                <h3>Stack-Based VM vs Register-Based VM</h3>
                
                <p>
                    I chose a stack-based architecture over register-based, because it's <em>much</em> simpler to implement. However, it's also slower because of more stack operations.
                </p>
                
                <p>
                    For Phase, I prioritized modularity and extensibility over raw performance. Besides, Phase's small scope means there wouldn't be any noticeable different between the two architectures.
                </p>
                
                <h2>What's Next</h2>
                
                <p>
                    Phase is finished for now, with enough features to write a variety of small, useful programs.
                </p>
                
                <p>
                    If I were to revisit it in the future, these would be the next features on my roadmap:
                </p>
                
                <ul>
                    <li><strong>An arena memory allocator</strong></li>
                    <li><strong>JIT bytecode compilation</strong></li>
                    <li><strong>Standard input</strong></li>
                    <li><strong>Aggregate data types</strong></li>
                </ul>
                
                <h2>What I Learned</h2>
                
                <p>Building Phase taught me more about programming languages than any course or book could. I now understand:</p>
                
                <ul>
                    <li>How compilers translate high-level code into executable instructions.</li>
                    <li>Why certain language features exist and what tradeoffs they involve.</li>
                    <li>How type systems work behind the scenes.</li>
                    <li>The complexity of seemingly simple things like lexing or error messages.</li>
                    <li>How to design systems that are both functional and easily extendable.</li>
                </ul>
                
                <p>
                    More importantly, it demonstrated two important things:
                </p>
                
                <p>
                    The power of project-based learning: I couldn't have learned all these skills if I didn't actually create my language.
                </p>
                
                <p>
                    And my ethos of computer science: providing the agency to turn hopeful imagination into working reality — to build what wasn't there before.
                </p>
                
                <p>
                    If you're thinking about creating your own language, this is my advice: you can plan a bit, get some ideas about syntax and pipelines, but just <em>start</em>. I made the mistake of spending a month just planning and reading; you'll learn quickly by just building it, piece-by-piece.
                </p>
                
                <p>
                    You can check out Phase on <a href="https://github.com/williamalexakis/phase" target="_blank" rel="noreferrer">GitHub</a>.
                </p>
            </div>
        </article>
    </main>
    
    <footer class="site-footer">
        <div class="wrapper footer__inner">
            © William Alexakis
        </div>
    </footer>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-nasm.min.js"></script>
</body>

</html>
